name: Seed Socrata history (one-time)

on:
  workflow_dispatch:
    inputs:
      game:
        description: 'Game to seed (powerball|megamillions|cash4life)'
        required: true
        type: choice
        options: [powerball, megamillions, cash4life]
      since:
        description: 'Era cutoff YYYY-MM-DD (e.g., 2015-10-07)'
        required: true
        type: string

permissions:
  contents: write

jobs:
  seed:
    runs-on: ubuntu-latest
    environment:
      name: r2-prod
    env:
      CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID || vars.CLOUDFLARE_ACCOUNT_ID }}
      CLOUDFLARE_API_TOKEN:  ${{ secrets.CLOUDFLARE_API_TOKEN }}
      R2_BUCKET:     ${{ secrets.R2_BUCKET || vars.R2_BUCKET }}
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with: { node-version: 20, cache: 'npm' }
      - run: npm ci
      - run: npm i -D wrangler@4
      - run: npx playwright install --with-deps chromium
      - name: Export Cloudflare env for Wrangler
        run: |
          echo "CLOUDFLARE_ACCOUNT_ID=$CLOUDFLARE_ACCOUNT_ID" >> $GITHUB_ENV
          echo "CLOUDFLARE_API_TOKEN=$CLOUDFLARE_API_TOKEN"   >> $GITHUB_ENV
      - name: Build seed CSV (full era since cutoff)
        env:
          SOCRATA_APP_TOKEN: ${{ secrets.SOCRATA_APP_TOKEN }}
          LSP_SEED_GAME: ${{ github.event.inputs.game }}
          LSP_SEED_SINCE: ${{ github.event.inputs.since }}
        run: node scripts/update_csvs.mjs
      # Reuse your existing merge/upload/verify steps (copy from update workflow):
      - name: Merge + Upload + Verify
        shell: bash
        run: |
            set -euo pipefail
            export LC_ALL=C LANG=C
            canon="draw_date,num1,num2,num3,num4,num5,special"

            fetch_plain () {
                local rel="$1"     # e.g. multi/cash4life.csv
                local out="$2"
                local tmp_raw
                tmp_raw="$(mktemp)"
                if ! npx --yes wrangler r2 object get "$R2_BUCKET/$rel" --file="$tmp_raw" --remote 1>/dev/null; then
                    return 1
                fi
                if gzip -t "$tmp_raw" 2>/dev/null || head -c2 "$tmp_raw" | od -An -t x1 | tr -d ' ' | grep -qi '^1f8b'; then
                    gunzip -c "$tmp_raw" > "$out"
                else
                    cp "$tmp_raw" "$out"
                fi
                }

            merge_csv() {
            local rel="$1"
            local local_file="public/data/$rel"

            sed -i 's/\r$//' "$local_file" 2>/dev/null || true

            local tmpdir r2_file r2_fixed local_fixed merged
            tmpdir="$(mktemp -d)"
            r2_file="$tmpdir/r2.csv"
            r2_fixed="$tmpdir/r2.fixed.csv"
            local_fixed="$tmpdir/local.fixed.csv"
            merged="$tmpdir/merged.csv"

            if fetch_plain "$rel" "$r2_file"; then
                echo "Fetched existing $rel from R2"
            else
                echo "No existing $rel in R2; starting fresh"
                : > "$r2_file"
            fi

            # Normalize R2 and local to canonical header
            npx tsx scripts/repair-lotto-csv.ts "$r2_file" "$r2_fixed"
            npx tsx scripts/repair-lotto-csv.ts "$local_file" "$local_fixed"

            # Optional visibility
            echo "R2 fixed header:    $(head -n1 "$r2_fixed"    || true)"
            echo "Local fixed header: $(head -n1 "$local_fixed" || true)"

            # If local is empty (no new rows), just keep R2
            if [ ! -s "$local_fixed" ] || [ "$(tail -n +2 "$local_fixed" | sed '/^[[:space:]]*$/d' | wc -l)" -eq 0 ]; then
                echo "No new local rows for $rel; keeping R2 version."
                cp "$r2_fixed" "$local_file"
                return 0
            fi

            # Final sanity: headers must be canonical now
            head -n1 "$r2_fixed" | tr -d '\r' | grep -qx "$canon" || { echo "R2 header not canonical after repair"; exit 1; }
            head -n1 "$local_fixed" | tr -d '\r' | grep -qx "$canon" || { echo "Local header not canonical after repair"; exit 1; }

            # Track previous row count for anti-truncation
            prev_rows=$(tail -n +2 "$r2_fixed" | sed '/^[[:space:]]*$/d' | wc -l || echo 0)

            # Merge append-only, unique by draw_date, sorted by date
            {
                echo "$canon"
                (tail -n +2 "$r2_fixed"; tail -n +2 "$local_fixed") \
                | sed '/^[[:space:]]*$/d' \
                | awk -F, '!seen[$1]++' \
                | sort
            } > "$merged"

            merged_rows=$(tail -n +2 "$merged" | sed '/^[[:space:]]*$/d' | wc -l || echo 0)
            if [ "$merged_rows" -lt "$prev_rows" ]; then
                echo "ERROR: Anti-truncation triggered for $rel (merged $merged_rows < previous $prev_rows)."
                cp "$r2_fixed" "$local_file"
            else
                mv "$merged" "$local_file"
            fi

            echo "Post-merge $rel rows: prev=$prev_rows â†’ now=$merged_rows"
            npx wrangler r2 object put "$R2_BUCKET/$rel" --file="$local_file" --content-type=text/csv --cache-control=public,max-age=3600,must-revalidate --remote
            echo "Uploaded $rel"
            }

            # Apply to the game you seeded; others are OK too.
            merge_csv multi/powerball.csv
            merge_csv multi/megamillions.csv
            merge_csv multi/cash4life.csv

      - name: Commit CSV changes only (safe)
        run: |
            set -e
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git restore --worktree --staged package.json package-lock.json 2>/dev/null || true
            git add public/data/ga public/data/multi
            if git diff --cached --quiet; then
            echo "No CSV changes to commit."
            exit 0
            fi
            echo "Changes to commit:"
            git diff --cached --name-status
            git commit -m "chore(seed): import Socrata history"
            git push
